{"name":"Solejs","tagline":"the soul of the console","body":"# sole.js\r\n_the soul of the console_\r\n\r\n<!--\r\n[![Build Status](https://secure.travis-ci.org/visionmedia/jade.png)](http://travis-ci.org/visionmedia/jade)\r\n-->\r\n\r\nsole.js is an extension of the console paradigm that includes tagging, filtering, globbing, plugins and event subscription.\r\n\r\n**Note:** sole.js does **not** override the console, (however there is a plugin for that, if you wish.)\r\n\r\n# Quick start\r\n\r\n* [Download the latest release](https://github.com/jsguy/solejs/zipball/master)\r\n* Include dist/sole-latest.min.js in your page\r\n* You can now do things like \r\n```js\r\nsole.tag('my').log('stuff');\r\n```\r\nand then later \r\n```js\r\nsole.filter('my')\r\n``` \r\nto get just your stuff!\r\n* Play around with the qunit tests to see how it all works!\r\n\r\n# Wait, why do I need this?\r\n\r\nWith the ability to use semantic tagging, and filtering output of commands, you can use it for example to create unit tests, catching issues cross-browser, perfomance tuning, troubleshooting, replacing the normal console, etc...\r\nThere is a plugin to generate qunit tests automatically by simply logging information at key points, check out the included qunitgenerator test!\r\n\r\n**Caveat emptor:** On the surface, having console commands everywhere and tightly coupling your code with a library seems like a bad idea, however sole.js is fully tested, and used in various high-traffic production sites. If you can live with that, read on!\r\n\r\n# Using it\r\n\r\n```js\r\nsole.log(\"Some gibberish\");\r\nsole.tag(\"useful\").log(\"Useful info\");\r\nsole.filter(\"useful\").get();\r\n// [{ args: [\"Useful info\"], tags: [\"useful\"], type: \"log\" }]\r\n```\r\nie: avoid the gibberish!\r\n\r\n## Simple example\r\n\r\nSay we had a function ```Func``` that we wanted to test - we could use sole to capture information from it at key points in the process.\r\n\r\n```js\r\nfunction Func(args) {\r\n    //\tPrivate function - we are naming the function here \r\n\tvar multiply = function multiply(num, times) {\r\n\t\t\tsole.log(num, times);\r\n\t\t\treturn num * times;\r\n\t\t}, value = multiply(args.num, args.times);\r\n\tthis.getValue = function getValue() {\r\n\t\tsole.log(value);\r\n\t\treturn value;\r\n\t};\r\n\tsole.log(\"Ran multiply\", value);\r\n};\r\n\r\n//\tCode we want to test, including any data\r\nvar myFunc = new Func({ num: 9, times: 6 });\r\n```\r\n\r\nsole will now contain the following:\r\n\r\n```js\r\n[\r\n    {\"type\":\"log\",\"tags\":[],\"args\":{\"0\":9,\"1\":6}},\r\n    {\"type\":\"log\",\"tags\":[],\"args\":{\"0\":\"Ran multiply\",\"1\":54}}\r\n]\r\n```\r\nYou can use this to test that the output result matches the given input, ie: Func received 9, 6 and returned 54, or in other words: 9 x 6 = 54.\r\n\r\n## Tagging\r\n\r\n```js\r\nsole.tag(yourTag)\r\n```\r\nWhere yourTag is one of\r\n\r\n* `string` most basic form of use\r\n* `array` alternatively pass in an array of tags\r\n\r\ntag is chainable, so you can do things like:\r\n\r\n```js\r\nsole.tag(\"blah\").log(\"something\").get();\r\n// [{ args: [\"something], tags: [\"blah\"], type: \"log\", time: date }]\r\n```\r\n\r\n\r\n**Note:** Tags are persistent, so once you set a tag, it will be reused for further messages.\r\n\r\n\r\n## Globbing\r\n\r\nSay you had:\r\n\r\n```js\r\nsole.tag(\"fruit.apple\").log(\"We have an apple\");\r\nsole.tag(\"fruit.apple.green\").log(\"We have a green apple\");\r\n```\r\nIf you run\r\n\r\n```js\r\nsole.glob(\"fruit.apple\").length\r\n```\r\nReturns 1 item\r\n\r\n```js\r\nsole.glob(\"fruit.apple*\").length\r\n```\r\nReturns 2 items\r\n\r\n## Filtering\r\n\r\n\r\n# Copyright and license\r\n\r\nCopyright 2013 jsguy (Mikkel Bergmann)\r\n\r\nLicensed under the MIT License","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}